{"version":3,"file":null,"sources":["../src/constant.js","../src/emitter/event_emitter.js","../src/metadata_reflector.js","../src/metadata_resolver.js","../src/emitter/event_aggregator.js","../src/emitter/window_postmessage_emitter.js","../src/emitter/index.js","../src/batscanner_module.js","../src/index.js"],"sourcesContent":["//\n\nimport { OpaqueToken } from '@angular/core'\n\n//\n\nexport const HAS_RUNTIME_METADATA_RESOLVER_HOOK = '__HAS_RUNTIME_METADATA_RESOLVER_HOOK__' // Make this a symbol\nexport const IS_PART_OF_THE_DEBUGGER = '__IS_PART_OF_THE_DEBUGGER__'\nexport const BATSCANNER_ID = '__BATSCANNER_ID__'\nexport const BATSCANNER_RECORD = '__BATSCANNER_RECORD__'\n\n//\n\nexport const BATSCANNER_ROOT_COMPONENT = new OpaqueToken('BATSCANNER_ROOT_COMPONENT')\n","//\n\nexport class BatscannerEventEmitter {\n  next () {}\n}\n","//\n\nimport {\n  IS_PART_OF_THE_DEBUGGER,\n  HAS_RUNTIME_METADATA_RESOLVER_HOOK\n} from './constant.js'\n\n//\n\nexport function needToBeScaned (directiveType) {\n  let requireRuntimeMetadataResolverHooks = true\n  requireRuntimeMetadataResolverHooks &= !directiveType[IS_PART_OF_THE_DEBUGGER]\n  requireRuntimeMetadataResolverHooks &= !directiveType[HAS_RUNTIME_METADATA_RESOLVER_HOOK]\n\n  return Boolean(requireRuntimeMetadataResolverHooks)\n}\n\nexport function markAsScaned (directiveType) {\n  directiveType[HAS_RUNTIME_METADATA_RESOLVER_HOOK] = true\n}\n","//\n\nimport {\n  __compiler_private__ as ngCompilerPrivateParts // eslint-disable-line camelcase\n} from '@angular/compiler'\n\nimport {Injector, resolveForwardRef} from '@angular/core'\nimport {\n  __core_private__ as ngCorePrivateParts // eslint-disable-line camelcase\n} from '@angular/core'\n\nimport {BatscannerEventEmitter} from './emitter/event_emitter.js'\nimport {needToBeScaned, markAsScaned} from './metadata_reflector.js'\nimport {BATSCANNER_ID} from './constant.js'\n\n//\n\nconst { LifecycleHooks, LIFECYCLE_HOOKS_VALUES } = ngCorePrivateParts\nconst { CompileMetadataResolver } = ngCompilerPrivateParts\nlet GLOBAL_ID = 0\n\n//\n\nexport class BatScannerCompileMetadataResolver extends CompileMetadataResolver {\n  constructor (\n    // HACK(@douglasduteil): Force inject the injector in the CompileMetadataResolver\n    _injector,\n    //\n    _ngModuleResolver,\n    _directiveResolver,\n    _pipeResolver,\n    _viewResolver,\n    _config,\n    _console,\n    _reflector\n  ) {\n    super(\n      _ngModuleResolver,\n      _directiveResolver,\n      _pipeResolver,\n      _viewResolver,\n      _config,\n      _console,\n      _reflector\n    )\n\n    this._eventEmitter = _injector.get(BatscannerEventEmitter)\n  }\n\n  getTypeMetadata (directiveType, moduleUrl, dependencies) {\n    directiveType = resolveForwardRef(directiveType)\n\n    if (!needToBeScaned(directiveType)) {\n      return super.getTypeMetadata(directiveType, moduleUrl, dependencies)\n    }\n\n    //\n\n    markAsScaned(directiveType)\n\n    //\n\n    const emitter = this._eventEmitter\n    directiveType.prototype = LIFECYCLE_HOOKS_VALUES.reduce(function (proto, lifecycleHook) {\n      const lifecycleHookName = LifecycleHooks[lifecycleHook]\n      let existingHook = proto[`ng${lifecycleHookName}`]\n\n      if (lifecycleHook === LifecycleHooks.OnInit) {\n        const originalHook = proto.ngOnInit\n        proto.ngOnInit = function ngOnInitBatScanner () {\n          this[BATSCANNER_ID] = GLOBAL_ID++\n          if (originalHook) {\n            originalHook.call(this)\n          }\n        }\n\n        existingHook = proto.ngOnInit\n      }\n\n      proto[`ng${lifecycleHookName}`] = function (changes) {\n        if (existingHook) {\n          existingHook.call(this, changes)\n        }\n\n        emitter.next({\n          id: this[BATSCANNER_ID],\n          timestamp: window.performance.now(),\n          type: lifecycleHookName,\n          targetName: directiveType.name,\n          target: directiveType,\n          changes: changes\n        })\n      }\n\n      return proto\n    }, directiveType.prototype)\n\n    return super.getTypeMetadata(directiveType, moduleUrl, dependencies)\n  }\n}\n\nBatScannerCompileMetadataResolver.ctorParameters =\n  // Copy CompileMetadataResolver.ctorParameters\n  CompileMetadataResolver.ctorParameters.map((token) => ({type: token.type}))\nBatScannerCompileMetadataResolver.ctorParameters.unshift({ type: Injector })\n","//\n\nimport {\n  __core_private__ as ngCorePrivateParts // eslint-disable-line camelcase\n} from '@angular/core'\n\nimport {Observable} from 'rxjs/Observable'\nimport {Subject} from 'rxjs/Subject'\n\n//\n\nconst { LifecycleHooks } = ngCorePrivateParts\n\n//\n\nexport function BatscannerEventAggregator () {\n  this.aggregateUntill = aggregateUntill\n}\n\n//\n\nfunction aggregateUntill (source, componentToken) {\n  // HACK(@douglasduteil): source filter triggered before the buffer problem\n  //\n  // Basic implementation would suggest to directly listen to the source\n  // without wrapping it in another Observable. But it's causing problem of\n  // notification ordnance. Indeed, if we subscribe to the source here, the\n  // first puller will be the closingNotifier$ and not the buffer$ that will\n  // start pulling after the client subscribe to the source. Thus the\n  // closingNotifier$ end the buffer$ before it has the chance to get the last\n  // event...\n  //\n  // We get :\n  //\n  // ```\n  //           source : ---A---B---C---X------------>\n  // closingNotifier$ : ---------------X------------>\n  //          buffer$ : ---------------[A, B, C]---->\n  // ```\n  //\n  // Instead of:\n  //\n  // ```\n  //           source : ---A---B---C---X------------>\n  //          buffer$ : ---------------[A, B, C, X]->\n  // closingNotifier$ : ---------------X------------>\n  // ```\n\n  const hasCheckedTheRootComponent =\n    rootComponentAfterViewChecked.bind(null, componentToken)\n\n  return Observable.create(aggregationObservable)\n\n  //\n\n  function aggregationObservable (observer) {\n    // Manually on next the buffer at the end of each RootComponent check\n    const everyRootComponentAfterViewChecked = new Subject()\n\n    // Must be the first to subscribe to source to buffer any incoming events\n    const buffer$ = source\n      .buffer(everyRootComponentAfterViewChecked)\n      .subscribe((e) => observer.next(e))\n\n    // Listen to the source for AfterViewChecked AFTER buffering stuff\n    const closingNotifier$ = source\n      .filter((e) => hasCheckedTheRootComponent(e))\n      .subscribe(() => everyRootComponentAfterViewChecked.next())\n\n    return function () {\n      buffer$.dispose()\n      closingNotifier$.dispose()\n    }\n  }\n}\n\nfunction rootComponentAfterViewChecked (root, event) {\n  const {type, target} = event\n  const isTheRootComponent = target === root\n  const isDoCheckEventType = LifecycleHooks[type] === LifecycleHooks.AfterViewChecked\n  return isTheRootComponent && isDoCheckEventType\n}\n","//\n\nimport {Injector} from '@angular/core'\nimport {Subject} from 'rxjs/Subject'\n\nimport {BATSCANNER_ROOT_COMPONENT} from '../constant.js'\n\nimport {BatscannerEventAggregator} from './event_aggregator.js'\n\n//\n\nBatscannerWindowPostMessageEmitter.ctorParameters = [{ type: Injector }]\nexport function BatscannerWindowPostMessageEmitter (injector) {\n  const rootComponent = injector.get(BATSCANNER_ROOT_COMPONENT)\n  const eventAggregator = injector.get(BatscannerEventAggregator)\n\n  //\n\n  window.TTT = true\n\n  const suject = new Subject()\n  this.next = suject.next.bind(suject)\n\n  //\n\n  const source = eventAggregator.aggregateUntill(suject, rootComponent)\n\n  //\n\n  source.subscribe(function postMessage (aggregatedEvents) {\n    console.log('#postMessage', aggregatedEvents)\n\n    window.postMessage({\n      source: 'foobar',\n      payload: JSON.parse(JSON.stringify(aggregatedEvents))\n    }, '*')\n  })\n}\n","//\n\nexport * from './event_emitter.js'\nexport * from './event_aggregator.js'\nexport * from './window_postmessage_emitter.js'\n\n","//\n\nimport {\n  __compiler_private__ as ngCompilerPrivateParts // eslint-disable-line camelcase\n} from '@angular/compiler'\n\nimport {BATSCANNER_ROOT_COMPONENT} from './constant.js'\nimport {BatScannerCompileMetadataResolver} from './metadata_resolver.js'\nimport {\n  BatscannerEventEmitter,\n  BatscannerWindowPostMessageEmitter,\n  BatscannerEventAggregator\n} from './emitter/index.js'\n\n//\n\nconst { CompileMetadataResolver } = ngCompilerPrivateParts\n\n//\nexport { BATSCANNER_ROOT_COMPONENT }\nexport const BATSCANNER_PROVIDERS = [\n  // TODO(@douglasduteil): clarrify if must be required by default or not\n  // Will throw\n  // \"DI Error caused by: No provider for Token BATSCANNER_ROOT_COMPONENT\"\n  // if not defined by the user\n  // {provide: BATSCANNER_ROOT_COMPONENT, useValue: ''},\n\n  {provide: CompileMetadataResolver, useClass: BatScannerCompileMetadataResolver},\n  {provide: BatscannerEventEmitter, useClass: BatscannerWindowPostMessageEmitter},\n\n\n  BatscannerEventAggregator\n]\n","//\n\nexport * from './batscanner_module.js'\n\n//\n"],"names":["HAS_RUNTIME_METADATA_RESOLVER_HOOK","IS_PART_OF_THE_DEBUGGER","BATSCANNER_ID","BATSCANNER_ROOT_COMPONENT","OpaqueToken","BatscannerEventEmitter","needToBeScaned","directiveType","requireRuntimeMetadataResolverHooks","Boolean","markAsScaned","LifecycleHooks","ngCorePrivateParts","LIFECYCLE_HOOKS_VALUES","CompileMetadataResolver","ngCompilerPrivateParts","GLOBAL_ID","BatScannerCompileMetadataResolver","_directiveResolver","_pipeResolver","_viewResolver","_config","_console","_reflector","_ngModuleResolver","_eventEmitter","_injector","get","moduleUrl","dependencies","resolveForwardRef","emitter","prototype","reduce","proto","lifecycleHook","lifecycleHookName","existingHook","OnInit","originalHook","ngOnInit","ngOnInitBatScanner","call","changes","next","window","performance","now","name","ctorParameters","map","token","type","unshift","Injector","BatscannerEventAggregator","aggregateUntill","source","componentToken","hasCheckedTheRootComponent","rootComponentAfterViewChecked","bind","Observable","create","aggregationObservable","observer","everyRootComponentAfterViewChecked","Subject","buffer$","buffer","subscribe","e","closingNotifier$","filter","dispose","root","event","target","isTheRootComponent","isDoCheckEventType","AfterViewChecked","BatscannerWindowPostMessageEmitter","injector","rootComponent","eventAggregator","TTT","suject","postMessage","aggregatedEvents","log","JSON","parse","stringify","BATSCANNER_PROVIDERS","provide","useClass"],"mappings":"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"}